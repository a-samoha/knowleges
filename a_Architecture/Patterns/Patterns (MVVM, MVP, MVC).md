#architecture 
[источник](https://habr.com/ru/company/mobileup/blog/313538/)
![[Pasted image 20220714164144.png]]
### MV**C**    (Model-View-Controller от Трюгве 1979)     
`Используем, когда View не умеет реагировать на действия пользователя (на клавиатуру, мышь и т.д.)`
**Модель** (ни о ком не знает) – это данные вашего приложения, логика их получения и сохранения. Зачастую это модель предметной области (_domain model_), основанная на базе данных или на результатах от веб-сервисов. В некоторых случаях _domain model_ хорошо проецируется на то, что вы видите на экране. Но иногда перед использованием ее необходимо адаптировать, изменить или расширить.
**View** (знает о модели) - отвечала за отображение UI на экране.  Также может наблюдать за моделью и отображать данные из неё.
**Controller** (знает все о всех) - обрабатывает действия пользователя и затем обновляет Model или View. Когда пользователь взаимодействует с приложением (нажимает кнопки на клавиатуре, передвигает курсор мыши), контроллер получает уведомление об этих действиях и решает, что с ними делать.
![[Pasted image 20220714174844.png]]
### MV**C**  (в Android)  `все знают обо всех`
` - View знает про Controller и передает ему результаты действий пользователя`
` - Controller выступает мапером, содержит бизнес логику и отправляет данные в модель (на хранение)`
` - Model знает про View и при уничтожении View нужно чистить ссылки на View живущие в Model`
-   Пользователь инициировал действие
-   Представление отвечает на контроллер и обрабатывает операцию.
-   Контроллер помещает обработанные данные в модель для сохранения
-   Модель возвращает данные обратно в представление
![[Pasted image 20220714174743.png]]

### MV**P**  (Model-View-Presenter)   `Разрывает связь между View и Model. Presenter умирает вместе с View`
` - View знает про Presenter и передает ему результаты действий пользователя`
` - Presenter знает про View и сетит нужные ему поля (забрал эти обязанности у Model из прошлого патерна). Также выступает мапером, содержит бизнес логику и отправляет данные в модель (на хранение)`
` - Model ни про кого не знает. Из него торчат несколько API методов и он отдает по ним данные любому, кому нужно`
**Модель** (ни о ком не знает) – это данные вашего приложения, логика их получения и сохранения. Зачастую она основана на базе данных или на результатах от веб-сервисов. В некоторых случаях потребуется ее адаптировать, изменить или расширить перед использованием во View.
**View** (знает о Presenter и НЕ знает о model) - Обычно представляет собой форму с виджетами. Пользователь может взаимодействовать с ее элементами, но когда какое-нибудь событие виджета будет затрагивать логику интерфейса, View будет направлять его в Presenter.
**Presenter** (знает все о всех) - Презентер содержит всю логику пользовательского интерфейса и отвечает за синхронизацию модели и представления. Когда представление уведомляет презентер, что пользователь что-то сделал (например, нажал кнопку), презентер принимает решение об обновлении модели и синхронизирует все изменения между моделью и представлением. **Презентер содержит ссылку на View** . При уничтожении View Презентер тоже должен уничтожиться

![[Pasted image 20220714172023.png]]
### MV**P**    (Model-View-Presenter)     Supervising Controller
В этом варианте MVP представление **знает** о модели и отвечает за связывание данных с отображением. Это делает общение между презентером и View более лаконичным, но в ущерб тестируемости взаимодействия View-Presenter. Лично я ненавижу тот факт, что этот паттерн содержит в названии «Controller». Потому что контроллер снова не тот, что в MVC и не такой, как Application Controller. `Больше похоже на паттерн MVC`

### MV**PM**    (Model-View-PresentationModel)
PresentationModel имеет несколько обязанностей:
1.  **Содержит логику пользовательского интерфейса:**  
    Так же, как и презентер, PresentationModel содержит логику пользовательского интерфейса. Когда вы нажимаете на кнопку, это событие направляется в PresentationModel, которая затем решает, что с ним делать.
2.  **Предоставляет данные из модели для отображения на экране**  
    PresentationModel может преобразовывать данные из модели так, чтобы они были легко отображены на экране. Обычно, сначала требуется преобразовать данные из модели, дополнить их или собрать из нескольких источников. Это наиболее вероятно, когда у вас нет полного контроля над моделью. Напр. Вы получаете данные от сторонних веб-сервисов или же из базы данных существующего приложения.
3.  **Хранит состояние пользовательского интерфейса**  
    Иногда UI должен хранить дополнительную информацию, которая не имеет ничего общего с моделью. Например, какой элемент выбран в данный момент на экране? Какие ошибки валидации произошли? PresentationModel может хранить эту информацию в свойствах.
![[Pasted image 20220714180031.png]]
### MV**VM**  (Model-View-ViewModel)    `Разрываем связь между View и ViewModel. ViewModel живет отдельно от View lifecycle`
` - View знает про ViewModel и передает ему результаты действий пользователя и САМА слушает изменения в нужных полях ViewModel (являющиеся Observables). В методе onDestroy() обязательно отписываемся от всех подписок на Observables`
` - ViewModel знает про Model и выступает мапером, содержит бизнес логику и отправляет данные в модель (на хранение)`
` - Model ни про кого не знает. Из него торчат несколько API методов и он отдает по ним данные любому, кому нужно`
Единственным отличием является явное использование возможностей связывания данных (_databinding_) в WPF и Silverlight.

ViewModel не может общаться со View напрямую. Вместо этого она представляет легко связываемые свойства и методы в виде [команд](http://msdn.microsoft.com/en-us/library/system.windows.input.icommand.aspx). View может привязываться к этим свойствам, чтобы получать информацию из ViewModel и вызывать на ней команды (методы). Это не требует того, чтобы View знала о ViewModel. XAML Databinding использует рефлексию, чтобы связать View и ViewModel. Таким образом, вы можете использовать любую ViewModel для View, которая предоставляет нужные свойства.
![[Pasted image 20220714180117.png]]
