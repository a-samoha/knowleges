## из книги "Идеальный Программист"

... в 1999 году я отправился в Медфорд, штат Орегон, чтобы встретиться с  
Кентом и научиться у него новой методологии. Результат был просто порази-  
тельным!  

Мы с Кентом сели у него в офисе и начали программировать простую задачу на  
Java. Я хотел просто написать свой примитивный код, но Кент воспротивился и  
провел меня по всему процессу шаг за шагом. Сначала он написал крошечную  
часть модульного теста, которую и кодом-то нельзя было назвать. Затем он на-  
писал код, достаточный для того, чтобы тест компилировался. Затем он написал  
еще один тест и еще немного кода.  

Такой рабочий цикл полностью противоречил всему моему опыту. Я привык пи-  
сать код не менее часа, прежде чем пытаться откомпилировать или запустить  
его. Но Кент буквально выполнял свой код каждые 30 секунд или около того.  
Это было невероятно! Но самое интересное, что этот рабочий цикл был мне зна-  
ком! Я сталкивался с ним много лет назад, когда еще ребенком18 программмиро-  
вал игры на интерпретируемых языках вроде Basic или Logo. В этих языках не  
было сборки как таковой: вы просто добавляли строку кода и запускали про-  
грамму. Рабочий цикл проходил очень быстро. И по этой причине программиро-  
вание на этих языках бывало очень производительным.  

Но в настоящем программировании такой рабочий цикл казался абсурдным. В  
настоящем программировании вы тратили много времени на написание кода, а  
потом еще больше времени на то, чтобы заставить его компилироваться. И еще  
больше времени на отладку. Я ведь был программистом С++, черт побери! А в  
С++ процессы сборки и компоновки могли длиться минутами, а то и часами.  
Тридцатисекундные рабочие циклы казались немыслимыми. Тем не менее, пе-  
редо мной сидел Кент, который писал свою программу на Java с 30-секундными  
циклами — и без малейшего намека на то, что работа замедлится. И тогда до ме-  
ня дошло, что эта простая методология позволяет программировать на настоя-  
щих языках с продолжительностью рабочего цикла, типичной для Logo! И я ка-  
питально «подсел» на TDD!

## Три закона TDD  

1. Новый рабочий код пишется только после того, как будет написан модульный  тест, который не проходит.  
2. Вы пишете ровно такой объем кода модульного теста, какой необходим для  того, чтобы этот тест не проходил 
   (если код теста не компилируется, считается,  что он не проходит).  
3. Вы пишете ровно такой объем рабочего кода, какой необходим для прохождения модульного теста,
   который в данный момент не проходит.

Эти три закона заставляют нас использовать рабочий цикл продолжительностью  
около 30 секунд. Сначала вы пишете маленькую часть модульного теста. За эти  
считанные секунды вы упоминаете в коде ими класса или функции, которые еще  
не были написаны; естественно, модульный тест не компилируется. Следова-  
тельно, далее вы должны написать рабочий код, с которым тест откомпилирует-  
ся. Но писать больше кода нельзя, поэтому вы переходите к написанию допол-  
нительного кода модульного теста.  

Цикл прокручивается снова и снова. Добавляем небольшой фрагмент в тестовый  
код. Добавляем небольшой фрагмент в рабочий код. Два кодовых потока растут  
одновременно, превращаясь во взаимодополняющие компоненты. Соответствие  
между тестами и рабочим кодом напоминает соответствие между антителом и  
антигеном.